<!doctype html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style id="distill-article-specific-styles">
    <%=require("../static/styles.css") %>
  </style>
  <script src="https://distill.pub/template.v2.js"></script>
</head>

<body>

  <d-front-matter>
    <script type="text/json">
      <%= JSON.stringify(require("./frontmatter.json"), null, 4) %>
    </script>
  </d-front-matter>

  <d-title>
    <h1>Constrained Policy Optimization (CPO)</h1>
    <p>An example project using Webpack, Babel, and Svelte. </p>
  </d-title>

  <d-article>

    <p>
      The implementation of the CPO algorithm is based on Achiam et al. <d-cite
          key="achiam2017constrained"></d-cite> 
    </p>
    
    <h4>Introduction</h4>
    <p>Constrained policy optimization (CPO) is a policy search algorithm for
	constrained Markov decision processes (CMDPs). The authors of Achiam et al. <d-cite
          key="achiam2017constrained"></d-cite> derive an update step which theoretically guarantees constraint satisfaction whilst not decreasing the reward function. In each iteration a problem of the following kind is approximately solved </p>
	<d-math block="">
      		\pi_{k+1} = \text{arg max}_{\pi \in \Pi_\theta} J(\pi),
    	</d-math>
    	<d-math block="">
      		\text{s.t. } J_{C_i}(\pi) \le d_i \text{ for } i=1,...,m, 
      		D_{kl}(\pi, \pi_k) \le \delta ,
    	</d-math>
   <p> where <d-math>\Pi_\theta</d-math> is some set of parametrized policies, <d-math>J:\Pi_\theta \to R</d-math> is some reward function, <d-math>J_{C_i}:\Pi_\theta \to R</d-math> are some constraint functions, <d-math>d_i</d-math> are the respective limits for <d-math>i = 1,...,m</d-math> and <d-math>D_{kl}</d-math> is the KL-divergence.
          For the practical implementation the theoretical mathematical objects in the problem above, we here only mentioned vaguely, are replaced by surrogate function which can be obtained by 				samples collected from evaluating the current policy. The problem then becomes</p>
          <d-math block="">
      		\theta_{k+1} = \text{arg max}_{\theta} g^T (\theta - \theta_k),
      		\text{s.t. } c_i + b_i^T(\theta - \theta_k) \le 0 \text{ for } i=1,...,m,
      		\frac{1}{2} (\theta - \theta_k)^T H (\theta - \theta_k) \le \delta ,
    	</d-math>
    	<p>where here <d-math>g</d-math> is the gradient of the objective function, <d-math>H</d-math> is the hessian of the KL-divergence, <d-math>b_i</d-math> is the gradient of the constraint function and <d-math>c_i</d-math> is the current value of the constraint function for <d-math>i = 1,...,m</d-math>. </p>
    	
    <h4> Results Showcase </h4>
    
    <p> We mainly used the CartPole and the LunarLander environment for our testing.
        In this section we present a model we trained in the LunarLander environment using the CPO algorithm.
    	For the constraint we decided to limit the speed of the aircraft.
    	This is implemented in our code in the following way.
    </p>
    	
    	<d-code block="" language="python">
	      def LunarLander_vel(state, dtype, device, bound=1.5):

		#state[:, 2] velocity in x direction, state[:, 3] velocity in y direction
		costs = torch.tensor(np.zeros(state.shape[0]), dtype=dtype).to(device)
		idx = torch.abs(state[:, 2]) + torch.abs(state[:, 3]) > bound
		costs[idx] = 1

		return costs </d-code>
	<p> In mathematical terms the constraint function is given by</p>
	<d-math block=""> C: R^8 \to R ~,~~C(s) = 1_{||(s_3, s_4)||_1} ~.</d-math>
    <p> The agent is punished with a constraint cost of 1 if the 1-norm of the velocity-vector is above 1.5, elsewhise if it is below this threshhold, the agent receives a constraint cost of 0. </p> 
    
    <p> Here is a video of several runs of our model after about 90 iterations. </p>
    
  <div style="display: flex; flex-direction: column; align-items: center; padding-top: 1em">
		<video controls width = "500" height = "400">
      <source src="images/LunarLander2.webm" type="video/webm">
      Interactive plot displaying learning progress for different numbers of CG-iterations within each iteration
		</video>
	</div>
    	
	
	<p> To visualize how well the model obeys to the constraint we plotted the speed of the aircraft throughout about 100 runs.
		Each trajactory resembles the speed of the agent during one run.
		As we can see almost all trajectories run below the limit.
	</p>
	
	<div style="display: flex; flex-direction: column; align-items: center; padding-top: 1em">
		<img src="images/speed_limit.svg" alt="Plot displaying the speed of the aircraft throughout a run" style="max-width: 1000px;"></img>
	</div>
	
	<p> Unfortunately we ran into multiple difficulties during training. For example in the LunarLander environment it was always the case that at some point the algorithm stopped working properly, sadly we could not figure ou why.</p>
	
	<div style="display: flex; flex-direction: column; align-items: center; padding-top: 1em">
		<img src="images/Lunarlander_training.svg" alt="Plot displaying the learning progress" style="max-width: 1000px;"></img>
	</div>
    	
    	<p> But we can see that for the first 100 iterations where the algorithm is working the constrained limit is being nicely tracked and the reward is increasing.</p>
    	
    	
    <h4> CG iteration </h4>
    
    <p> As seen in the introductory part computing the CPO update involves a lot of expressions as <d-math> H^{-1}b, H^{-1}g </d-math>.
    	Computing the inverse of a matrix is computationally very expensive, hence Achiam et al. <d-cite
          key="achiam2017constrained"></d-cite> advice the reader to circumvent it, by instead solving the linear algebraic systems <d-math> Hx = b</d-math> and <d-math> Hx = g</d-math>
          respectively. Obviously in exact arithmetics the respective solutions would give us the quantities we are looking for, but as most of us only have access to the floating point numbers in the IEEE 754 standard, 
          for this matter we will have to resort to some approximation. Here Achiam et al. <d-cite
          key="achiam2017constrained"></d-cite> propose to use the CG Algorithm, this is an iterative method for solving linear algebraic systems particularly designed for symmetric positiv-definite matrices, cf. <d-cite
          key="liesen2023"></d-cite> chapter 4.2.
    </p>
    <p> To observe the influence of the quality of the approximation of said quantities we ran the CPO algorithm with different numbers of CG-iterations.
    	Our hypothesis was that increasing the number of iterations would lead to an improvement in the learning progress.
    	Since the better approximation would lead to more accurate steps and thus 
    	the practical implemantation would be closer to the theoretically derived update.
    </p>
    	
    <d-figure id="cgits-visualization">
      <figure>
        <div id="cgits-visualization-target" class="image" style="max-width: 2000px;"></div>
        <figcaption>
          Learning progress and constraint satisfaction in the LunarLander and CartPole environment for various agents trained with different numbers of CG-iterations within each update step. <br>
          In the LunarLander environment the agent was supposed to not surpase a certain speed whilst for CartPole he was supposed to stay whithin the middle section of the screen.
        </figcaption>
      </figure>
    </d-figure>
    
    <p> To further understand the impact of the increased amount of CG-iterations we had a look at the relative forward error.
    For a linear algebraic system <d-math> Ax = b </d-math> this quantity is given by
    	<d-math>
      		\frac{||x-\hat{x}||}{||x||}
    	</d-math>
    	for some approximation <d-math> \hat{x} </d-math> and some norm <d-math> ||\cdot|| </d-math>, this value is useful to evaluate the quality of an estimation. As we do not know the exact solution <d-math> x </d-math> in most cases, we can only use bounds to assess it.
    	One such bound we are going to use, is the following</p>
    <d-math block="">
      		\frac{||x-\hat{x}||}{||x||} \le K(A) \frac{||r||}{||b||},
    	</d-math>
    <p>where <d-math> K(A) </d-math> is the condition number of <d-math> A </d-math> w.r.t. <d-math> ||\cdot|| </d-math> and <d-math> r = b - A\hat{x} </d-math> is the residual.
    This bound tells us, if the matrix <d-math> A </d-math> has a reasonable condition number a small residual implies a good approximation.</p>
    	
    <d-figure id="residual-visualization">
      <figure>
        <div id="residual-visualization-target" class="image" style="max-width: 2000px;"></div>
        <figcaption>
          Plot of the residual and bound on the relative forward error with respect to the 2-norm, here <d-math> r1 = ||b - H\hat{x}||_2 </d-math> and <d-math> r2 = ||g - H\hat{x}||_2 </d-math>.
        </figcaption>
      </figure>
    </d-figure>
    
    <p> Indeed we can see in the second graph that increasing the number of CG-iterations to fifty and above drastically lowers the residualnorm and the bound on relative forward error.
    Also for both environments for 10 and 20 CG-iterations the bound on the relative forward error sometimes lies way beyond 1, implying that the approximation might not be better than a random guess. On the other hand, in terms of the reward when looking at the first graph the impact is not noticeable, it behaves rather similar for all four different values.
    One explanation could be that our approximation of the consdition number of <d-math> H </d-math> is too pesimistic. </p>
    
    <d-figure id="constraint-visualization">
      <figure>
        <div id="constraint-visualization-target" class="image" style="max-width: 2000px;"></div>
        <figcaption>
          Direct comparison between 10 and 100 CG-iterations of the behaviour of the constraint value.
        </figcaption>
      </figure>
    </d-figure>
    
    <p> Only when considering the constraint value one could argue that increasing the number of CG-iterations leads to a somewhat more stable behaviour during training. 
    Moreover to further justify this point for oneself one would have to ignore the last 25 iterations in the LunarLander environment.
    All in all our experiments seem to indicate that the impact of the number of CG-iterations is rather subtle and does not considerably improve the training proccess,
    obviously for more reliable results more experiments would need to be conducted.</p>

    <h4>Interactive Figures</h4>

    <p>
      Here's a dynamically instantiated "figure". We use Intersection Observers to allow loading resource-heavy
      figures only when readers scroll close to them. The code for this is in <code>src/index.js</code>.
    </p>

    <d-figure id="svelte-example-dfigure">
      <figure>
        <div id="svelte-example-target"></div>
        <figcaption>And a static figcaption. You can use citations<d-cite key="mercier2011humans"></d-cite> in this
          figcaption, but not in text added by javascript.</figcaption>
      </figure>
    </d-figure>

    <p>You can't use citation tags (<code>d-cite</code>) in figures that are dynamically loaded using Javascript.
      Distill statically
      analyzes your submission for its citations, because they need to be uploaded to indexers and organizations like <a
        href="https://www.crossref.org/">CrossRef</a> and <a href="https://scholar.google.com">Google Scholar</a>.</p>

    <p>That's it for the example article! Feel free to look at <a
        href="https://github.com/distillpub?utf8=%E2%9C%93&q=post--&type=public">implementations
        of existing Distill articles</a>, or ask for help in
      the <a href="http://slack.distill.pub">Distill Slack Community</a>.</p>

  </d-article>



  <d-appendix>
    <h3>Acknowledgments</h3>
    <p>
      We are deeply grateful to...
    </p>

    <p>
      Many of our diagrams are based on...
    </p>

    <h3>Author Contributions</h3>
    <p>
      <b>Research:</b> Alex developed ...
    </p>

    <p>
      <b>Writing & Diagrams:</b> The text was initially drafted by...
    </p>


    <d-footnote-list></d-footnote-list>
    <d-citation-list></d-citation-list>
  </d-appendix>

  <!-- bibliography will be inlined during Distill pipeline's pre-rendering -->
  <d-bibliography src="bibliography.bib"></d-bibliography>

</body>
